
// for maximum speed GPIO operation: compile in fastest, define void yield, disable all interrupts, use digitalwritefast (and static pin numbers), and set slew rates and drive strengths to fast.
// also, for very short for loops the compiler will type it out longhand anyways, but for longer loops, ie, toggle a pin 1000 times, it's actually better to type it
// out 1000 times, or you lose 4 clock cycles everytime the loop refreshes. Obviously, this cannot continue forever as there is limited memory. And it looks kind of funny.
// also, manually index into arrays, where possible.
// this gets single clock cycle output control, which for a teensy 3.2 running at 100Mhz (ok, 96Mhz), this is roughly 10nS per pin toggle.

#ifndef CCDRead_h
#define CCDRead_h

#include "Arduino.h"
#include "GlobalVariables.h"

// DEFINING THIS FUNCTION IS CRITICAL TO MAXIMUM SPEED OPERATION!!! IT DOESN'T EVEN HAVE TO GET CALLED ANYWHERE
void yield () {} //Get rid of the hidden function that checks for serial input and such. 

// FASTRUN loads this entire function into RAM, which may run faster if the cache is overflowing- FLASH access is only 24Mhz
// so there could be additional 3 cycle delays. Of course, it eats RAM. Also, the teensy only has 1 cycle access to the lower
// 50% of RAM, so if the sketch uses more than that, the bonus is reduced.
void scanCCD_SOFTCODED(){
  cli();
  lngTotalizer = 0;
  lngPositionTotalizer = 0;

  digitalWriteFast(pinSTARTREAD, HIGH); // initial pulse to start the read
  __asm__ __volatile__ ("nop\n\t"); // initial delay for this first pulse
  // Pulse #0, CCD is 16 cycles behind for setup, and ADC is 3 cycles behind that
  digitalWriteFast(pinADCCLOCK8BIT,LOW); // TRIGGER ADC SAMPLE, old value still present on outputs
  digitalWriteFast(pinREADCLOCK,HIGH); // TRIGGER CCD SHIFT, analog value will begin heading to new value
  INTccdRaw[0] = GPIOC_PDIR & 0xFF; // READ ADC old value (actually 3 cycles old, due to pipeline structure)
  lngTotalizer += INTccdRaw[0]; // USE DEAD TIME while we don't have to interact with hardware to compute some math
  digitalWriteFast(pinADCCLOCK8BIT,HIGH); // TELL ADC TO CHANGE OUTPUTS, will begin moving the next sample to outputs. output is momentarily invalid.
  digitalWriteFast(pinREADCLOCK,LOW); // ADC CLOCK, no action happens, all events on rising edge.
  digitalWriteFast(pinSTARTREAD,LOW); // end of initial pulse to start the read
  lngPositionTotalizer += INTccdRaw[0]*0; // USE DEAD TIME while we don't have to interact with hardware to compute some math
  
  for (int i = 1; i < intCCDResolution+21; i++){
    digitalWriteFast(pinADCCLOCK8BIT,LOW); // TRIGGER ADC SAMPLE, old value still present on outputs
    digitalWriteFast(pinREADCLOCK,HIGH); // TRIGGER CCD SHIFT, analog value will begin heading to new value
    INTccdRaw[i] = GPIOC_PDIR & 0xFF; // READ ADC old value (actually 3 cycles old, due to pipeline structure)
    lngTotalizer += INTccdRaw[i]; // USE DEAD TIME while we don't have to interact with hardware to compute some math
    digitalWriteFast(pinADCCLOCK8BIT,HIGH); // TELL ADC TO CHANGE OUTPUTS, will begin moving the next sample to outputs. output is momentarily invalid.
    digitalWriteFast(pinREADCLOCK,LOW); // ADC CLOCK, no action happens, all events on rising edge.
    lngPositionTotalizer += INTccdRaw[i]*i; // USE DEAD TIME while we don't have to interact with hardware to compute some math
  }

  sei()
}

void scanCCD_HARDCODED256(){
  // THIS CODE GENERATED BY PYTHON SCRIPT
  // MUST BE INLINE FOR TIMING ACCURACY AND SPEED
  // MUST HAVE HARDCODED ARRAY INDEX ACCESS FOR SPEED
  // Note the math index for pixel location indexes from 1. This is because multiplying by 0 gets optimized
  // out by the compiler, causing the first sample to have a different timing than the rest.

  cli();
  lngTotalizer = 0;
  lngPositionTotalizer = 0;
  sei();
}

#endif
